"""Handles creation, loading, and rollback of patch files."""

import logging
import json
from pathlib import Path
from datetime import datetime, timezone
from typing import Optional, List, Tuple

import diff_match_patch as dmp_module  # Import dmp

logger = logging.getLogger(__name__)

PATCH_FILE_SUFFIX = ".bidian-patch"


class PatchError(Exception):
    """Base exception for patch-related errors."""
    pass


class PatchFormatError(PatchError):
    """Exception for invalid patch file format."""
    pass


class PatchApplyError(PatchError):
    """Exception for errors during patch application/rollback."""
    pass


# Initialize DMP object once
dmp = dmp_module.diff_match_patch()


def get_patch_path(target_file_path: Path) -> Path:
    """Generates the corresponding patch file path for a target file.

    Appends the patch suffix to the original filename.

    Args:
        target_file_path: The path to the original file (created or modified).

    Returns:
        The Path object for the corresponding patch file.
    """
    return target_file_path.with_suffix(target_file_path.suffix + PATCH_FILE_SUFFIX)


def save_creation_patch(created_note_path: Path) -> Optional[Path]:
    """Saves a patch file indicating a note was created.

    The patch file contains metadata about the creation action.

    Args:
        created_note_path: The absolute path to the newly created note file.

    Returns:
        The Path to the saved patch file, or None if saving failed.
    """
    patch_path = get_patch_path(created_note_path)
    patch_data = {
        "action": "create",
        "target_path": str(created_note_path.resolve()),
        "timestamp_utc": datetime.now(timezone.utc).isoformat(),
        "patch_format": "metadata_only"  # Clarify format
    }
    try:
        patch_path.parent.mkdir(parents=True, exist_ok=True)  # Ensure dir exists
        with open(patch_path, 'w', encoding='utf-8') as f:
            json.dump(patch_data, f, indent=2)
        logger.info(f"Saved creation patch file: {patch_path}")
        return patch_path
    except OSError as e:
        logger.error(
            f"Failed to save creation patch file {patch_path}: {e}", exc_info=True)
        return None
    except Exception as e:
        logger.error(
            f"Unexpected error saving creation patch {patch_path}: {e}", exc_info=True)
        return None


def save_refactor_patch(
    target_file_path: Path,
    original_content: str,  # Added original content
    diff: List[Tuple[int, str]]  # Keep diff for potential future use/inspection
) -> Optional[Path]:
    """Saves a patch file for a refactor action.

    Stores the original content for reliable rollback and optionally the diff.

    Args:
        target_file_path: The absolute path to the refactored note file.
        original_content: The full content of the note *before* refactoring.
        diff: The diff list generated by diff-match-patch (optional for rollback).

    Returns:
        The Path to the saved patch file, or None if saving failed.
    """
    patch_path = get_patch_path(target_file_path)
    # Convert diff to patch text for potential inspection, though not used for rollback now
    patch_text = ""
    try:
        patches = dmp.patch_make(diff)
        patch_text = dmp.patch_toText(patches)
    except Exception as e:
        logger.warning(
            f"Failed to generate patch text for {target_file_path}: {e}. Patch file will lack diff text.", exc_info=True)
        # Continue without patch_text

    patch_data = {
        "action": "refactor",
        "target_path": str(target_file_path.resolve()),
        "timestamp_utc": datetime.now(timezone.utc).isoformat(),
        "patch_format": "original_content",  # Indicate rollback method
        "original_content": original_content,
        "patch_diff_text": patch_text  # Store for info, but don't rely on it for rollback
    }
    try:
        patch_path.parent.mkdir(parents=True, exist_ok=True)
        with open(patch_path, 'w', encoding='utf-8') as f:
            # Use higher separators compactness for potentially large original_content
            json.dump(patch_data, f, separators=(',', ':'))
        logger.info(
            f"Saved refactor patch file (storing original content): {patch_path}")
        return patch_path
    except OSError as e:
        logger.error(
            f"Failed to save refactor patch file {patch_path}: {e}", exc_info=True)
        return None
    except Exception as e:
        logger.error(
            f"Unexpected error saving refactor patch {patch_path}: {e}", exc_info=True)
        return None


def rollback_creation_patch(patch_file_path: Path) -> None:
    """Rolls back a 'create' action by deleting the target file and the patch file.

    Args:
        patch_file_path: The path to the .bidian-patch file.

    Raises:
        PatchFormatError: If the patch file is invalid or not a 'create' action.
        PatchApplyError: If deleting the target file or patch file fails.
        FileNotFoundError: If the patch file itself doesn't exist.
    """
    logger.info(f"Attempting to roll back creation using patch: {patch_file_path}")
    if not patch_file_path.is_file():
        raise FileNotFoundError(f"Patch file not found: {patch_file_path}")

    try:
        with open(patch_file_path, 'r', encoding='utf-8') as f:
            patch_data = json.load(f)
    except (OSError, json.JSONDecodeError) as e:
        raise PatchFormatError(
            f"Failed to read or parse patch file {patch_file_path}: {e}") from e

    # Validate patch data
    action = patch_data.get("action")
    target_path_str = patch_data.get("target_path")
    if action != "create" or not target_path_str:
        raise PatchFormatError(
            f"Patch file {patch_file_path} is not a valid 'create' patch. Action: '{action}'"
        )

    target_path = Path(target_path_str)
    logger.info(f"Rollback target identified: {target_path}")

    # Delete the target file (if it exists)
    if target_path.exists():
        if target_path.is_file():
            try:
                target_path.unlink()
                logger.info(f"Successfully deleted target file: {target_path}")
            except OSError as e:
                raise PatchApplyError(
                    f"Failed to delete target file {target_path} during rollback: {e}") from e
        else:
            # Should generally not happen if patch is correct, but handle anyway
            raise PatchApplyError(
                f"Target path {target_path} exists but is not a file. Cannot rollback creation.")
    else:
        logger.warning(
            f"Target file {target_path} did not exist. Assuming rollback already partially done or file moved.")

    # Delete the patch file itself
    try:
        patch_file_path.unlink()
        logger.info(f"Successfully deleted patch file: {patch_file_path}")
    except OSError as e:
        # Log error but don't necessarily fail the whole rollback if target was deleted
        logger.error(
            f"Failed to delete patch file {patch_file_path} after rollback: {e}")
        # Optionally re-raise: raise PatchApplyError(...) from e


def rollback_refactor_patch(patch_file_path: Path) -> None:
    """Rolls back a 'refactor' action by restoring the original content.

    Args:
        patch_file_path: The path to the .bidian-patch file.

    Raises:
        PatchFormatError: If the patch file is invalid, not a 'refactor' patch,
                          or missing the original_content.
        PatchApplyError: If reading the patch file or writing the target file fails.
        FileNotFoundError: If the patch file itself doesn't exist.
    """
    logger.info(f"Attempting to roll back refactor using patch: {patch_file_path}")
    if not patch_file_path.is_file():
        raise FileNotFoundError(f"Patch file not found: {patch_file_path}")

    # 1. Load patch data
    try:
        with open(patch_file_path, 'r', encoding='utf-8') as f:
            patch_data = json.load(f)
    except (OSError, json.JSONDecodeError) as e:
        raise PatchFormatError(
            f"Failed to read or parse patch file {patch_file_path}: {e}") from e

    # 2. Validate patch data
    action = patch_data.get("action")
    target_path_str = patch_data.get("target_path")
    patch_format = patch_data.get("patch_format")  # Check format indicator
    original_content = patch_data.get("original_content")  # Get original content

    if action != "refactor" or patch_format != "original_content" or not target_path_str or original_content is None:
        raise PatchFormatError(
            f"Patch file {patch_file_path} is not a valid 'refactor' patch storing original content."
        )

    target_path = Path(target_path_str)
    logger.info(f"Rollback target identified: {target_path}")

    # 3. Write the original content back to the target file
    # This overwrites the current content, effectively rolling back.
    # We don't necessarily need to check if the target exists; if it doesn't,
    # writing will recreate it (which might be unexpected, but simpler than erroring).
    # If needed, add an existence check here.
    try:
        target_path.parent.mkdir(parents=True, exist_ok=True)  # Ensure directory exists
        target_path.write_text(original_content, encoding='utf-8')
        logger.info(f"Successfully restored original content to: {target_path}")
    except OSError as e:
        raise PatchApplyError(
            f"Failed to write restored content to {target_path}: {e}") from e
    except Exception as e:
        raise PatchApplyError(
            f"Unexpected error writing restored content to {target_path}: {e}") from e

    # 4. Delete the patch file
    try:
        patch_file_path.unlink()
        logger.info(f"Successfully deleted patch file: {patch_file_path}")
    except OSError as e:
        logger.error(
            f"Failed to delete patch file {patch_file_path} after rollback: {e}")
        # Decide if this should raise PatchApplyError
